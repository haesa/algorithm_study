# 입력: N, N개의 숫자 (N: 수열의 크기)
# 로직:
#   증가하는 부분 수열은 왼쪽 원소와 오른쪽 원소를 비교했을 때 오른쪽이 항상 커야 한다.
#   증가하는 부분 수열을 구하는 과정에서 두 개의 원소를 비교하는 연산이 필요한데, 이 과정에서 같은 값을 비교하는 중복 연산이 반복된다.
#   중복 연산 방지를 위해 DP를 사용해서 문제를 풀이해볼 수 있다.
#   DP[i]를 i번째 원소를 마지막으로 갖는 증가하는 부분 수열의 길이라고 하자.
#   각 원소만을 갖는 부분 수열은 모두 존재하므로 1로 초기화할 수 있다.
#   이후 i번째 원소를 j = i - 1, i - 2, ..., 0번째와 원소와 비교한다.
#   i번째 원소가 더 크다는 건 부분 증가 수열 조건을 만족한다는 의미기 때문에 DP[i]를 DP[j] + 1 값으로 갱신할 수 있다.
#   다만 문제에서 최대 길이를 구하라고 했기 때문에 기존 DP[i]와 비교해서 더 큰 값으로 갱신해야 한다.
#   모든 연산을 마친 후 DP 배열에 있는 값 중 가장 큰 값이 가장 긴 증가하는 부분 수열의 길이가 된다.
# 출력: 가장 긴 증가하는 부분 수열의 길이

import sys

input = sys.stdin.readline

N = int(input())
arr = list(map(int, input().split()))

dp = [1] * N  # 각 원소를 "마지막 원소로 가지는" 증가하는 부분 수열의 최대 길이를 담는 배열
for i in range(1, N):
    for j in range(i):  # 기준값 앞에 위치하는 원소들을 순회하며 크기 비교
        if arr[i] > arr[j]: 
            dp[i] = max(dp[i], dp[j] + 1) # 기준값이 더 큰 경우 증가하는 부분 수열의 조건을 만족하므로 dp[j] + 1과 dp[i] 중 더 큰 값으로 갱신
print(max(dp))  # 각 원소를 마지막으로 하는 증가하는 부분 수열의 최대 길이 중 최댓값 출력